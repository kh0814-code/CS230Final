# CS230Final
The Gaming Room – Software Design Document 
Client and Requirements

The client, The Gaming Room, currently runs a game called Draw It or Lose It on Android devices. They wanted to expand the application to other platforms but needed a design for a more scalable, secure, and efficient software system. Their main requirements included support for multiple teams, players, synchronized gameplay across platforms, strong user authentication, and clear management of game sessions.

What I Did Well

I think I did particularly well in analyzing the client’s requirements and translating them into clear design elements. I was able to capture both the functional requirements (like multiplayer support and session handling) and non-functional requirements (like scalability, security, and maintainability).

Helpful Parts of the Process

Working through the design document was helpful because it forced me to think through architecture and constraints before writing code. Defining the system in UML diagrams and structured requirements gave me a roadmap that made implementation more straightforward and less error-prone.

What I Would Revise

If I were to revise one part, I would improve the UML diagrams. While they covered the major components, I think they could be more detailed in showing interactions between modules and external systems. Adding clearer sequence diagrams would make the flow of requests and responses easier to understand for both the client and developers.

Considering the User’s Needs

I interpreted the user’s needs by looking beyond just the technical requirements. For example, the need for cross-platform support wasn’t just about portability but it was about ensuring that all users, regardless of device, could join the same game session seamlessly. Considering the user’s needs is crucial because ultimately, the success of the software depends on how well it solves the end-user’s problem and provides a smooth, enjoyable experience.

Approach to Software Design

My approach focused on modular design, scalability, and maintainability. I broke the system down into logical components and emphasized role-based access and data integrity. In future projects, I would continue using techniques like UML modeling, iterative refinement, and requirement traceability. These help ensure that every user need is accounted for and that the design is adaptable to future changes.
